#![allow(bad_style)]
/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub type __intmax_t = u64;
pub type __uintmax_t = u64;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::core::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::core::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::core::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::core::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
pub const EAPUSampleRate_ASR_44_100_Hz: EAPUSampleRate = 0;
pub const EAPUSampleRate_ASR_22_050_Hz: EAPUSampleRate = 1;
pub const EAPUSampleRate_ASR_11_025_Hz: EAPUSampleRate = 2;
pub const EAPUSampleRate_ASR_Halt: EAPUSampleRate = 3;
pub type EAPUSampleRate = ::core::ffi::c_uint;
pub type _off_t = u32;
pub type _fpos_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SJoystickState {
    pub count: u32,
    pub axis: [f32; 6usize],
    pub buttons: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SJoystickState"][::core::mem::size_of::<SJoystickState>() - 32usize];
    ["Alignment of SJoystickState"][::core::mem::align_of::<SJoystickState>() - 4usize];
    ["Offset of field: SJoystickState::count"]
        [::core::mem::offset_of!(SJoystickState, count) - 0usize];
    ["Offset of field: SJoystickState::axis"]
        [::core::mem::offset_of!(SJoystickState, axis) - 4usize];
    ["Offset of field: SJoystickState::buttons"]
        [::core::mem::offset_of!(SJoystickState, buttons) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SKeyboardState {
    pub count: u32,
    pub scancode: u32,
    pub state: u32,
    pub modifiers: u32,
    pub ascii: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SKeyboardState"][::core::mem::size_of::<SKeyboardState>() - 20usize];
    ["Alignment of SKeyboardState"][::core::mem::align_of::<SKeyboardState>() - 4usize];
    ["Offset of field: SKeyboardState::count"]
        [::core::mem::offset_of!(SKeyboardState, count) - 0usize];
    ["Offset of field: SKeyboardState::scancode"]
        [::core::mem::offset_of!(SKeyboardState, scancode) - 4usize];
    ["Offset of field: SKeyboardState::state"]
        [::core::mem::offset_of!(SKeyboardState, state) - 8usize];
    ["Offset of field: SKeyboardState::modifiers"]
        [::core::mem::offset_of!(SKeyboardState, modifiers) - 12usize];
    ["Offset of field: SKeyboardState::ascii"]
        [::core::mem::offset_of!(SKeyboardState, ascii) - 16usize];
};
pub type __gnuc_va_list = u32;
pub type va_list = __builtin_va_list;
pub type taskfunc = ::core::option::Option<unsafe extern "C" fn()>;
pub const ETaskState_TS_UNKNOWN: ETaskState = 0;
pub const ETaskState_TS_PAUSED: ETaskState = 1;
pub const ETaskState_TS_RUNNING: ETaskState = 2;
pub const ETaskState_TS_TERMINATING: ETaskState = 3;
pub const ETaskState_TS_TERMINATED: ETaskState = 4;
pub type ETaskState = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STask {
    pub HART: u32,
    pub runLength: u32,
    pub state: ETaskState,
    pub exitCode: u32,
    pub regs: [u32; 32usize],
    pub name: [::core::ffi::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of STask"][::core::mem::size_of::<STask>() - 160usize];
    ["Alignment of STask"][::core::mem::align_of::<STask>() - 4usize];
    ["Offset of field: STask::HART"][::core::mem::offset_of!(STask, HART) - 0usize];
    ["Offset of field: STask::runLength"][::core::mem::offset_of!(STask, runLength) - 4usize];
    ["Offset of field: STask::state"][::core::mem::offset_of!(STask, state) - 8usize];
    ["Offset of field: STask::exitCode"][::core::mem::offset_of!(STask, exitCode) - 12usize];
    ["Offset of field: STask::regs"][::core::mem::offset_of!(STask, regs) - 16usize];
    ["Offset of field: STask::name"][::core::mem::offset_of!(STask, name) - 144usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STaskContext {
    pub tasks: [STask; 4usize],
    pub currentTask: i32,
    pub numTasks: i32,
    pub kernelError: i32,
    pub kernelErrorData: [i32; 3usize],
    pub hartID: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of STaskContext"][::core::mem::size_of::<STaskContext>() - 668usize];
    ["Alignment of STaskContext"][::core::mem::align_of::<STaskContext>() - 4usize];
    ["Offset of field: STaskContext::tasks"][::core::mem::offset_of!(STaskContext, tasks) - 0usize];
    ["Offset of field: STaskContext::currentTask"]
        [::core::mem::offset_of!(STaskContext, currentTask) - 640usize];
    ["Offset of field: STaskContext::numTasks"]
        [::core::mem::offset_of!(STaskContext, numTasks) - 644usize];
    ["Offset of field: STaskContext::kernelError"]
        [::core::mem::offset_of!(STaskContext, kernelError) - 648usize];
    ["Offset of field: STaskContext::kernelErrorData"]
        [::core::mem::offset_of!(STaskContext, kernelErrorData) - 652usize];
    ["Offset of field: STaskContext::hartID"]
        [::core::mem::offset_of!(STaskContext, hartID) - 664usize];
};
pub type __FILE = __BindgenOpaqueArray<u32, 26usize>;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _bindgen_opaque_blob: [u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _glue"][::core::mem::size_of::<_glue>() - 12usize];
    ["Alignment of _glue"][::core::mem::align_of::<_glue>() - 4usize];
};
#[repr(C)]
#[repr(align(8))]
pub struct _reent {
    pub _bindgen_opaque_blob: [u64; 36usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u64; 25usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u64; 25usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>() - 200usize];
    ["Alignment of _reent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent__bindgen_ty_1"][::core::mem::size_of::<_reent__bindgen_ty_1>() - 200usize];
    ["Alignment of _reent__bindgen_ty_1"][::core::mem::align_of::<_reent__bindgen_ty_1>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent"][::core::mem::size_of::<_reent>() - 288usize];
    ["Alignment of _reent"][::core::mem::align_of::<_reent>() - 8usize];
};
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub const EVideoMode_EVM_320_Wide: EVideoMode = 0;
pub const EVideoMode_EVM_640_Wide: EVideoMode = 1;
pub const EVideoMode_EVM_Count: EVideoMode = 2;
pub type EVideoMode = ::core::ffi::c_uint;
pub const EColorMode_ECM_8bit_Indexed: EColorMode = 0;
pub const EColorMode_ECM_16bit_RGB: EColorMode = 1;
pub const EColorMode_ECM_Count: EColorMode = 2;
pub type EColorMode = ::core::ffi::c_uint;
pub const EVideoScanoutEnable_EVS_Disable: EVideoScanoutEnable = 0;
pub const EVideoScanoutEnable_EVS_Enable: EVideoScanoutEnable = 1;
pub const EVideoScanoutEnable_EVS_Count: EVideoScanoutEnable = 2;
pub type EVideoScanoutEnable = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVideoContext {
    pub m_vmode: EVideoMode,
    pub m_cmode: EColorMode,
    pub m_scanEnable: EVideoScanoutEnable,
    pub m_strideInWords: u32,
    pub m_scanoutAddressCacheAligned: u32,
    pub m_cpuWriteAddressCacheAligned: u32,
    pub m_graphicsWidth: u32,
    pub m_graphicsHeight: u32,
    pub m_consoleWidth: u16,
    pub m_consoleHeight: u16,
    pub m_cursorX: u16,
    pub m_cursorY: u16,
    pub m_consoleUpdated: u16,
    pub m_caretX: u16,
    pub m_caretY: u16,
    pub m_consoleColor: u8,
    pub m_caretBlink: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EVideoContext"][::core::mem::size_of::<EVideoContext>() - 48usize];
    ["Alignment of EVideoContext"][::core::mem::align_of::<EVideoContext>() - 4usize];
    ["Offset of field: EVideoContext::m_vmode"]
        [::core::mem::offset_of!(EVideoContext, m_vmode) - 0usize];
    ["Offset of field: EVideoContext::m_cmode"]
        [::core::mem::offset_of!(EVideoContext, m_cmode) - 4usize];
    ["Offset of field: EVideoContext::m_scanEnable"]
        [::core::mem::offset_of!(EVideoContext, m_scanEnable) - 8usize];
    ["Offset of field: EVideoContext::m_strideInWords"]
        [::core::mem::offset_of!(EVideoContext, m_strideInWords) - 12usize];
    ["Offset of field: EVideoContext::m_scanoutAddressCacheAligned"]
        [::core::mem::offset_of!(EVideoContext, m_scanoutAddressCacheAligned) - 16usize];
    ["Offset of field: EVideoContext::m_cpuWriteAddressCacheAligned"]
        [::core::mem::offset_of!(EVideoContext, m_cpuWriteAddressCacheAligned) - 20usize];
    ["Offset of field: EVideoContext::m_graphicsWidth"]
        [::core::mem::offset_of!(EVideoContext, m_graphicsWidth) - 24usize];
    ["Offset of field: EVideoContext::m_graphicsHeight"]
        [::core::mem::offset_of!(EVideoContext, m_graphicsHeight) - 28usize];
    ["Offset of field: EVideoContext::m_consoleWidth"]
        [::core::mem::offset_of!(EVideoContext, m_consoleWidth) - 32usize];
    ["Offset of field: EVideoContext::m_consoleHeight"]
        [::core::mem::offset_of!(EVideoContext, m_consoleHeight) - 34usize];
    ["Offset of field: EVideoContext::m_cursorX"]
        [::core::mem::offset_of!(EVideoContext, m_cursorX) - 36usize];
    ["Offset of field: EVideoContext::m_cursorY"]
        [::core::mem::offset_of!(EVideoContext, m_cursorY) - 38usize];
    ["Offset of field: EVideoContext::m_consoleUpdated"]
        [::core::mem::offset_of!(EVideoContext, m_consoleUpdated) - 40usize];
    ["Offset of field: EVideoContext::m_caretX"]
        [::core::mem::offset_of!(EVideoContext, m_caretX) - 42usize];
    ["Offset of field: EVideoContext::m_caretY"]
        [::core::mem::offset_of!(EVideoContext, m_caretY) - 44usize];
    ["Offset of field: EVideoContext::m_consoleColor"]
        [::core::mem::offset_of!(EVideoContext, m_consoleColor) - 46usize];
    ["Offset of field: EVideoContext::m_caretBlink"]
        [::core::mem::offset_of!(EVideoContext, m_caretBlink) - 47usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVideoSwapContext {
    pub cycle: u32,
    pub readpage: *mut u8,
    pub writepage: *mut u8,
    pub framebufferA: *mut u8,
    pub framebufferB: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EVideoSwapContext"][::core::mem::size_of::<EVideoSwapContext>() - 20usize];
    ["Alignment of EVideoSwapContext"][::core::mem::align_of::<EVideoSwapContext>() - 4usize];
    ["Offset of field: EVideoSwapContext::cycle"]
        [::core::mem::offset_of!(EVideoSwapContext, cycle) - 0usize];
    ["Offset of field: EVideoSwapContext::readpage"]
        [::core::mem::offset_of!(EVideoSwapContext, readpage) - 4usize];
    ["Offset of field: EVideoSwapContext::writepage"]
        [::core::mem::offset_of!(EVideoSwapContext, writepage) - 8usize];
    ["Offset of field: EVideoSwapContext::framebufferA"]
        [::core::mem::offset_of!(EVideoSwapContext, framebufferA) - 12usize];
    ["Offset of field: EVideoSwapContext::framebufferB"]
        [::core::mem::offset_of!(EVideoSwapContext, framebufferB) - 16usize];
};
pub type __builtin_va_list = u32;
unsafe extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn strtoumax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn wcstoimax(arg1: *const u32, arg2: *mut *mut u32, arg3: ::core::ffi::c_int) -> intmax_t;
    pub fn wcstoumax(arg1: *const u32, arg2: *mut *mut u32, arg3: ::core::ffi::c_int) -> uintmax_t;
    #[link_name = "\u{1}_Z17APUAllocateBufferj"]
    pub fn APUAllocateBuffer(_size: u32) -> *mut u8;
    #[link_name = "\u{1}_Z16APUSetBufferSizej"]
    pub fn APUSetBufferSize(audioBufferSize: u32);
    #[link_name = "\u{1}_Z11APUStartDMAj"]
    pub fn APUStartDMA(audioBufferAddress16byteAligned: u32);
    #[link_name = "\u{1}_Z16APUSetSampleRate14EAPUSampleRate"]
    pub fn APUSetSampleRate(sampleRate: EAPUSampleRate);
    #[link_name = "\u{1}_Z11E32ReadTimev"]
    pub fn E32ReadTime() -> u64;
    #[link_name = "\u{1}_Z13E32ReadCyclesv"]
    pub fn E32ReadCycles() -> u64;
    #[link_name = "\u{1}_Z26E32ReadRetiredInstructionsv"]
    pub fn E32ReadRetiredInstructions() -> u64;
    #[link_name = "\u{1}_Z17E32SetTimeComparey"]
    pub fn E32SetTimeCompare(future: u64);
    #[link_name = "\u{1}_Z9ClockToMsy"]
    pub fn ClockToMs(clk: u64) -> u32;
    #[link_name = "\u{1}_Z9ClockToUsy"]
    pub fn ClockToUs(clk: u64) -> u32;
    #[link_name = "\u{1}_Z12ClockMsToHMSjPjS_S_"]
    pub fn ClockMsToHMS(ms: u32, hours: *mut u32, minutes: *mut u32, seconds: *mut u32);
    #[link_name = "\u{1}_Z8E32Sleepy"]
    pub fn E32Sleep(ticks: u64);
    #[link_name = "\u{1}_Z20E32WriteMemMappedCSRjjj"]
    pub fn E32WriteMemMappedCSR(_hart: u32, _csr: u32, _value: u32);
    #[link_name = "\u{1}_Z19E32ReadMemMappedCSRjj"]
    pub fn E32ReadMemMappedCSR(_hart: u32, _csr: u32) -> u32;
    #[link_name = "\u{1}_Z11E32SetupCPUjPv"]
    pub fn E32SetupCPU(hartid: u32, workerThread: *mut ::core::ffi::c_void);
    #[link_name = "\u{1}_Z11E32ResetCPUj"]
    pub fn E32ResetCPU(hartid: u32);
    #[link_name = "\u{1}_Z13E32ClearResetj"]
    pub fn E32ClearReset(hartid: u32);
    #[link_name = "\u{1}_Z23E32BeginCriticalSectionv"]
    pub fn E32BeginCriticalSection();
    #[link_name = "\u{1}_Z21E32EndCriticalSectionv"]
    pub fn E32EndCriticalSection();
    #[link_name = "\u{1}_Z16E32GetScratchpadv"]
    pub fn E32GetScratchpad() -> u32;
    pub fn getcwd(buf: *mut ::core::ffi::c_char, size: usize) -> *mut ::core::ffi::c_char;
    pub fn chdir(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z13ReadAxisStatePh"]
    pub fn ReadAxisState(scandata: *mut u8);
    #[link_name = "\u{1}_Z16ProcessAxisStatePh"]
    pub fn ProcessAxisState(scandata: *mut u8);
    #[link_name = "\u{1}_Z15ReadButtonStatePh"]
    pub fn ReadButtonState(scandata: *mut u8);
    #[link_name = "\u{1}_Z18ProcessButtonStatePh"]
    pub fn ProcessButtonState(scandata: *mut u8);
    #[link_name = "\u{1}_Z19UpdateJoystickStatev"]
    pub fn UpdateJoystickState();
    #[link_name = "\u{1}_Z16JoystickGetStatev"]
    pub fn JoystickGetState() -> *mut SJoystickState;
    #[link_name = "\u{1}_Z12ReadKeyStatePh"]
    pub fn ReadKeyState(scandata: *mut u8);
    #[link_name = "\u{1}_Z15ProcessKeyStatePh"]
    pub fn ProcessKeyState(scandata: *mut u8);
    #[link_name = "\u{1}_Z19UpdateKeyboardStatePh"]
    pub fn UpdateKeyboardState(scandata: *mut u8);
    #[link_name = "\u{1}_Z16KeyboardGetStatev"]
    pub fn KeyboardGetState() -> *mut SKeyboardState;
    #[link_name = "\u{1}_Z23KeyboardScanCodeToASCIIhh"]
    pub fn KeyboardScanCodeToASCII(scanCode: u8, lowercase: u8) -> u8;
    #[link_name = "\u{1}_Z18KeyRingBufferResetv"]
    pub fn KeyRingBufferReset();
    #[link_name = "\u{1}_Z17KeyRingBufferReadPvj"]
    pub fn KeyRingBufferRead(pvDest: *mut ::core::ffi::c_void, cbDest: u32) -> u32;
    #[link_name = "\u{1}_Z18KeyRingBufferWritePKvj"]
    pub fn KeyRingBufferWrite(pvSrc: *const ::core::ffi::c_void, cbSrc: u32) -> u32;
    #[link_name = "\u{1}_Z11LEDGetStatev"]
    pub fn LEDGetState() -> u32;
    #[link_name = "\u{1}_Z11LEDSetStatej"]
    pub fn LEDSetState(state: u32);
    pub fn mini_vsnprintf(
        buffer: *mut ::core::ffi::c_char,
        buffer_len: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        va: va_list,
    ) -> ::core::ffi::c_int;
    pub fn mini_snprintf(
        buffer: *mut ::core::ffi::c_char,
        buffer_len: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z9c_isspacei"]
    pub fn c_isspace(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z9c_isdigiti"]
    pub fn c_isdigit(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z8c_sscanfPKcPcz"]
    pub fn c_sscanf(
        buff: *const ::core::ffi::c_char,
        format: *mut ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z7c_getchv"]
    pub fn c_getch() -> ::core::ffi::c_char;
    #[link_name = "\u{1}_Z11c_getbackchc"]
    pub fn c_getbackch(b: ::core::ffi::c_char) -> bool;
    #[link_name = "\u{1}_Z5getchv"]
    pub fn getch() -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z13SDCardStartupv"]
    pub fn SDCardStartup() -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z11SDIOControlhPv"]
    pub fn SDIOControl(cmd: u8, buffer: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z20SDReadMultipleBlocksPhjj"]
    pub fn SDReadMultipleBlocks(
        datablock: *mut u8,
        numblocks: u32,
        blockaddress: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z21SDWriteMultipleBlocksPKhjj"]
    pub fn SDWriteMultipleBlocks(
        datablock: *const u8,
        numblocks: u32,
        blockaddress: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z23SerialInRingBufferResetv"]
    pub fn SerialInRingBufferReset();
    #[link_name = "\u{1}_Z22SerialInRingBufferReadPvj"]
    pub fn SerialInRingBufferRead(pvDest: *mut ::core::ffi::c_void, cbDest: u32) -> u32;
    #[link_name = "\u{1}_Z23SerialInRingBufferWritePKvj"]
    pub fn SerialInRingBufferWrite(pvSrc: *const ::core::ffi::c_void, cbSrc: u32) -> u32;
    #[link_name = "\u{1}_Z14TaskGetContextj"]
    pub fn TaskGetContext(_hartid: u32) -> *mut STaskContext;
    #[link_name = "\u{1}_Z19TaskGetSharedMemoryv"]
    pub fn TaskGetSharedMemory() -> *mut ::core::ffi::c_void;
    #[link_name = "\u{1}_Z7TaskAddP12STaskContextPKcPFvvE10ETaskStatejj"]
    pub fn TaskAdd(
        _ctx: *mut STaskContext,
        _name: *const ::core::ffi::c_char,
        _task: taskfunc,
        _initialState: ETaskState,
        _runLength: u32,
        _stackAddress: u32,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z16TaskSwitchToNextP12STaskContext"]
    pub fn TaskSwitchToNext(_ctx: *mut STaskContext) -> u32;
    #[link_name = "\u{1}_Z19TaskExitCurrentTaskP12STaskContext"]
    pub fn TaskExitCurrentTask(_ctx: *mut STaskContext);
    #[link_name = "\u{1}_Z18TaskExitTaskWithIDP12STaskContextjj"]
    pub fn TaskExitTaskWithID(_ctx: *mut STaskContext, _taskid: u32, _signal: u32);
    #[link_name = "\u{1}_Z9TaskYieldv"]
    pub fn TaskYield();
    #[link_name = "\u{1}_Z12TaskSetStateP12STaskContextj10ETaskState"]
    pub fn TaskSetState(_ctx: *mut STaskContext, _taskid: u32, _state: ETaskState);
    #[link_name = "\u{1}_Z12TaskGetStateP12STaskContextj"]
    pub fn TaskGetState(_ctx: *mut STaskContext, _taskid: u32) -> ETaskState;
    #[link_name = "\u{1}_Z9TaskGetPCP12STaskContextj"]
    pub fn TaskGetPC(_ctx: *mut STaskContext, _taskid: u32) -> u32;
    pub fn atan(arg1: f64) -> f64;
    pub fn cos(arg1: f64) -> f64;
    pub fn sin(arg1: f64) -> f64;
    pub fn tan(arg1: f64) -> f64;
    pub fn tanh(arg1: f64) -> f64;
    pub fn frexp(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
    pub fn ceil(arg1: f64) -> f64;
    pub fn fabs(arg1: f64) -> f64;
    pub fn floor(arg1: f64) -> f64;
    pub fn acos(arg1: f64) -> f64;
    pub fn asin(arg1: f64) -> f64;
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
    pub fn cosh(arg1: f64) -> f64;
    pub fn sinh(arg1: f64) -> f64;
    pub fn exp(arg1: f64) -> f64;
    pub fn ldexp(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
    pub fn log(arg1: f64) -> f64;
    pub fn log10(arg1: f64) -> f64;
    pub fn pow(arg1: f64, arg2: f64) -> f64;
    pub fn sqrt(arg1: f64) -> f64;
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
    pub fn infinity() -> f64;
    pub fn nan(arg1: *const ::core::ffi::c_char) -> f64;
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
    pub fn logb(arg1: f64) -> f64;
    pub fn ilogb(arg1: f64) -> ::core::ffi::c_int;
    pub fn asinh(arg1: f64) -> f64;
    pub fn cbrt(arg1: f64) -> f64;
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
    pub fn rint(arg1: f64) -> f64;
    pub fn scalbn(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
    pub fn exp2(arg1: f64) -> f64;
    pub fn scalbln(arg1: f64, arg2: ::core::ffi::c_long) -> f64;
    pub fn tgamma(arg1: f64) -> f64;
    pub fn nearbyint(arg1: f64) -> f64;
    pub fn lrint(arg1: f64) -> ::core::ffi::c_long;
    pub fn llrint(arg1: f64) -> ::core::ffi::c_longlong;
    pub fn round(arg1: f64) -> f64;
    pub fn lround(arg1: f64) -> ::core::ffi::c_long;
    pub fn llround(arg1: f64) -> ::core::ffi::c_longlong;
    pub fn trunc(arg1: f64) -> f64;
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::core::ffi::c_int) -> f64;
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
    pub fn log1p(arg1: f64) -> f64;
    pub fn expm1(arg1: f64) -> f64;
    pub fn acosh(arg1: f64) -> f64;
    pub fn atanh(arg1: f64) -> f64;
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
    pub fn gamma(arg1: f64) -> f64;
    pub fn lgamma(arg1: f64) -> f64;
    pub fn erf(arg1: f64) -> f64;
    pub fn erfc(arg1: f64) -> f64;
    pub fn log2(arg1: f64) -> f64;
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
    pub fn atanf(arg1: f32) -> f32;
    pub fn cosf(arg1: f32) -> f32;
    pub fn sinf(arg1: f32) -> f32;
    pub fn tanf(arg1: f32) -> f32;
    pub fn tanhf(arg1: f32) -> f32;
    pub fn frexpf(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
    pub fn ceilf(arg1: f32) -> f32;
    pub fn fabsf(arg1: f32) -> f32;
    pub fn floorf(arg1: f32) -> f32;
    pub fn acosf(arg1: f32) -> f32;
    pub fn asinf(arg1: f32) -> f32;
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
    pub fn coshf(arg1: f32) -> f32;
    pub fn sinhf(arg1: f32) -> f32;
    pub fn expf(arg1: f32) -> f32;
    pub fn ldexpf(arg1: f32, arg2: ::core::ffi::c_int) -> f32;
    pub fn logf(arg1: f32) -> f32;
    pub fn log10f(arg1: f32) -> f32;
    pub fn powf(arg1: f32, arg2: f32) -> f32;
    pub fn sqrtf(arg1: f32) -> f32;
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
    pub fn exp2f(arg1: f32) -> f32;
    pub fn scalblnf(arg1: f32, arg2: ::core::ffi::c_long) -> f32;
    pub fn tgammaf(arg1: f32) -> f32;
    pub fn nearbyintf(arg1: f32) -> f32;
    pub fn lrintf(arg1: f32) -> ::core::ffi::c_long;
    pub fn llrintf(arg1: f32) -> ::core::ffi::c_longlong;
    pub fn roundf(arg1: f32) -> f32;
    pub fn lroundf(arg1: f32) -> ::core::ffi::c_long;
    pub fn llroundf(arg1: f32) -> ::core::ffi::c_longlong;
    pub fn truncf(arg1: f32) -> f32;
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::core::ffi::c_int) -> f32;
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
    pub fn infinityf() -> f32;
    pub fn nanf(arg1: *const ::core::ffi::c_char) -> f32;
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
    pub fn logbf(arg1: f32) -> f32;
    pub fn ilogbf(arg1: f32) -> ::core::ffi::c_int;
    pub fn asinhf(arg1: f32) -> f32;
    pub fn cbrtf(arg1: f32) -> f32;
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
    pub fn rintf(arg1: f32) -> f32;
    pub fn scalbnf(arg1: f32, arg2: ::core::ffi::c_int) -> f32;
    pub fn log1pf(arg1: f32) -> f32;
    pub fn expm1f(arg1: f32) -> f32;
    pub fn acoshf(arg1: f32) -> f32;
    pub fn atanhf(arg1: f32) -> f32;
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
    pub fn gammaf(arg1: f32) -> f32;
    pub fn lgammaf(arg1: f32) -> f32;
    pub fn erff(arg1: f32) -> f32;
    pub fn erfcf(arg1: f32) -> f32;
    pub fn log2f(arg1: f32) -> f32;
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn getchar() -> ::core::ffi::c_int;
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn fread(arg1: *mut ::core::ffi::c_void, _size: usize, _n: usize, arg2: *mut FILE)
    -> usize;
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
    pub fn rewind(arg1: *mut FILE);
    pub fn clearerr(arg1: *mut FILE);
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn perror(arg1: *const ::core::ffi::c_char);
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
    -> *mut FILE;
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vscanf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z21UARTInterceptSetStatei"]
    pub fn UARTInterceptSetState(state: ::core::ffi::c_int);
    #[link_name = "\u{1}_Z13UARTGetStatusv"]
    pub fn UARTGetStatus() -> u32;
    #[link_name = "\u{1}_Z14UARTSetControlj"]
    pub fn UARTSetControl(ctl: u32);
    #[link_name = "\u{1}_Z15UARTReceiveDatav"]
    pub fn UARTReceiveData() -> u32;
    #[link_name = "\u{1}_Z12UARTSendByteh"]
    pub fn UARTSendByte(data: u8);
    #[link_name = "\u{1}_Z13UARTSendBlockPhj"]
    pub fn UARTSendBlock(data: *mut u8, numBytes: u32);
    #[link_name = "\u{1}_Z10UARTPrintfPKcz"]
    pub fn UARTPrintf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z17VPUAllocateBufferj"]
    pub fn VPUAllocateBuffer(_size: u32) -> *mut u8;
    #[link_name = "\u{1}_Z16VPUGetDimensions10EVideoModePjS0_"]
    pub fn VPUGetDimensions(_mode: EVideoMode, _width: *mut u32, _height: *mut u32);
    #[link_name = "\u{1}_Z20VPUSetDefaultPaletteP13EVideoContext"]
    pub fn VPUSetDefaultPalette(_context: *mut EVideoContext);
    #[link_name = "\u{1}_Z11VPUSetVModeP13EVideoContext19EVideoScanoutEnable"]
    pub fn VPUSetVMode(_context: *mut EVideoContext, _scanEnable: EVideoScanoutEnable);
    #[link_name = "\u{1}_Z20VPUSetScanoutAddressP13EVideoContextj"]
    pub fn VPUSetScanoutAddress(_context: *mut EVideoContext, _scanOutAddress64ByteAligned: u32);
    #[link_name = "\u{1}_Z18VPUSetWriteAddressP13EVideoContextj"]
    pub fn VPUSetWriteAddress(_context: *mut EVideoContext, _cpuWriteAddress64ByteAligned: u32);
    #[link_name = "\u{1}_Z9VPUSetPalhjjj"]
    pub fn VPUSetPal(_paletteIndex: u8, _red: u32, _green: u32, _blue: u32);
    #[link_name = "\u{1}_Z20VPUReadVBlankCounterv"]
    pub fn VPUReadVBlankCounter() -> u32;
    #[link_name = "\u{1}_Z14VPUGetScanlinev"]
    pub fn VPUGetScanline() -> u32;
    #[link_name = "\u{1}_Z12VPUSwapPagesP13EVideoContextP17EVideoSwapContext"]
    pub fn VPUSwapPages(_vx: *mut EVideoContext, _sc: *mut EVideoSwapContext);
    #[link_name = "\u{1}_Z12VPUWaitVSyncv"]
    pub fn VPUWaitVSync();
    #[link_name = "\u{1}_Z14VPUPrintStringP13EVideoContexthhttPKci"]
    pub fn VPUPrintString(
        _context: *mut EVideoContext,
        _foregroundIndex: u8,
        _backgroundIndex: u8,
        _x: u16,
        _y: u16,
        _message: *const ::core::ffi::c_char,
        _length: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}_Z19VPUConsoleSetColorsP13EVideoContexthh"]
    pub fn VPUConsoleSetColors(
        _context: *mut EVideoContext,
        _foregroundIndex: u8,
        _backgroundIndex: u8,
    );
    #[link_name = "\u{1}_Z15VPUConsoleClearP13EVideoContext"]
    pub fn VPUConsoleClear(_context: *mut EVideoContext);
    #[link_name = "\u{1}_Z19VPUConsoleSetCursorP13EVideoContexttt"]
    pub fn VPUConsoleSetCursor(_context: *mut EVideoContext, _x: u16, _y: u16);
    #[link_name = "\u{1}_Z15VPUConsolePrintP13EVideoContextPKci"]
    pub fn VPUConsolePrint(
        _context: *mut EVideoContext,
        _message: *const ::core::ffi::c_char,
        _length: ::core::ffi::c_int,
    );
    #[link_name = "\u{1}_Z17VPUConsoleResolveP13EVideoContext"]
    pub fn VPUConsoleResolve(_context: *mut EVideoContext);
    #[link_name = "\u{1}_Z18VPUConsoleSetCaretP13EVideoContextttt"]
    pub fn VPUConsoleSetCaret(_context: *mut EVideoContext, _x: u16, _y: u16, _blink: u16);
    #[link_name = "\u{1}_Z19VPUConsoleClearLineP13EVideoContextt"]
    pub fn VPUConsoleClearLine(_context: *mut EVideoContext, _y: u16);
    #[link_name = "\u{1}_Z18VPUConsoleFillLineP13EVideoContextc"]
    pub fn VPUConsoleFillLine(
        _context: *mut EVideoContext,
        _character: ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[link_name = "\u{1}_Z18VPUConsoleScrollUpP13EVideoContext"]
    pub fn VPUConsoleScrollUp(_context: *mut EVideoContext);
    #[link_name = "\u{1}_Z8VPUClearP13EVideoContextj"]
    pub fn VPUClear(_context: *mut EVideoContext, _colorWord: u32);
    #[link_name = "\u{1}_Z22VPUGetKernelGfxContextv"]
    pub fn VPUGetKernelGfxContext() -> *mut EVideoContext;
}
