#![allow(bad_style)]
/* automatically generated by rust-bindgen 0.71.1 */

#[doc = r" If Bindgen could only determine the size and alignment of a"]
#[doc = r" type, it is represented like this."]
#[derive(PartialEq, Copy, Clone, Debug, Hash)]
#[repr(C)]
pub struct __BindgenOpaqueArray<T: Copy, const N: usize>(pub [T; N]);
impl<T: Copy + Default, const N: usize> Default for __BindgenOpaqueArray<T, N> {
    fn default() -> Self {
        Self([<T as Default>::default(); N])
    }
}
pub type __int_least64_t = u64;
pub type __intmax_t = u64;
pub type __uintmax_t = u64;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::core::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::core::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::core::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::core::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
pub const EAPUSampleRate_ASR_44_100_Hz: EAPUSampleRate = 0;
pub const EAPUSampleRate_ASR_22_050_Hz: EAPUSampleRate = 1;
pub const EAPUSampleRate_ASR_11_025_Hz: EAPUSampleRate = 2;
pub const EAPUSampleRate_ASR_Halt: EAPUSampleRate = 3;
pub type EAPUSampleRate = ::core::ffi::c_uint;
pub type _off_t = u32;
pub type __off_t = u32;
pub type _fpos_t = u32;
pub type __suseconds_t = u32;
pub type __sigset_t = u32;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::core::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::core::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::core::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::core::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::core::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type sigset_t = __sigset_t;
pub type __fd_mask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::core::mem::size_of::<fd_set>() - 8usize];
    ["Alignment of fd_set"][::core::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::__fds_bits"][::core::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type off_t = __off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SJoystickState {
    pub count: u32,
    pub axis: [f32; 6usize],
    pub buttons: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SJoystickState"][::core::mem::size_of::<SJoystickState>() - 32usize];
    ["Alignment of SJoystickState"][::core::mem::align_of::<SJoystickState>() - 4usize];
    ["Offset of field: SJoystickState::count"]
        [::core::mem::offset_of!(SJoystickState, count) - 0usize];
    ["Offset of field: SJoystickState::axis"]
        [::core::mem::offset_of!(SJoystickState, axis) - 4usize];
    ["Offset of field: SJoystickState::buttons"]
        [::core::mem::offset_of!(SJoystickState, buttons) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SKeyboardState {
    pub count: u32,
    pub scancode: u32,
    pub state: u32,
    pub modifiers: u32,
    pub ascii: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SKeyboardState"][::core::mem::size_of::<SKeyboardState>() - 20usize];
    ["Alignment of SKeyboardState"][::core::mem::align_of::<SKeyboardState>() - 4usize];
    ["Offset of field: SKeyboardState::count"]
        [::core::mem::offset_of!(SKeyboardState, count) - 0usize];
    ["Offset of field: SKeyboardState::scancode"]
        [::core::mem::offset_of!(SKeyboardState, scancode) - 4usize];
    ["Offset of field: SKeyboardState::state"]
        [::core::mem::offset_of!(SKeyboardState, state) - 8usize];
    ["Offset of field: SKeyboardState::modifiers"]
        [::core::mem::offset_of!(SKeyboardState, modifiers) - 12usize];
    ["Offset of field: SKeyboardState::ascii"]
        [::core::mem::offset_of!(SKeyboardState, ascii) - 16usize];
};
pub type __gnuc_va_list = u32;
pub type va_list = __builtin_va_list;
pub type taskfunc = ::core::option::Option<unsafe extern "C" fn()>;
pub const ETaskState_TS_UNKNOWN: ETaskState = 0;
pub const ETaskState_TS_PAUSED: ETaskState = 1;
pub const ETaskState_TS_RUNNING: ETaskState = 2;
pub const ETaskState_TS_TERMINATING: ETaskState = 3;
pub const ETaskState_TS_TERMINATED: ETaskState = 4;
pub type ETaskState = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STask {
    pub HART: u32,
    pub runLength: u32,
    pub state: ETaskState,
    pub exitCode: u32,
    pub regs: [u32; 32usize],
    pub name: [::core::ffi::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of STask"][::core::mem::size_of::<STask>() - 160usize];
    ["Alignment of STask"][::core::mem::align_of::<STask>() - 4usize];
    ["Offset of field: STask::HART"][::core::mem::offset_of!(STask, HART) - 0usize];
    ["Offset of field: STask::runLength"][::core::mem::offset_of!(STask, runLength) - 4usize];
    ["Offset of field: STask::state"][::core::mem::offset_of!(STask, state) - 8usize];
    ["Offset of field: STask::exitCode"][::core::mem::offset_of!(STask, exitCode) - 12usize];
    ["Offset of field: STask::regs"][::core::mem::offset_of!(STask, regs) - 16usize];
    ["Offset of field: STask::name"][::core::mem::offset_of!(STask, name) - 144usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STaskContext {
    pub tasks: [STask; 4usize],
    pub currentTask: i32,
    pub numTasks: i32,
    pub kernelError: i32,
    pub kernelErrorData: [i32; 3usize],
    pub hartID: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of STaskContext"][::core::mem::size_of::<STaskContext>() - 668usize];
    ["Alignment of STaskContext"][::core::mem::align_of::<STaskContext>() - 4usize];
    ["Offset of field: STaskContext::tasks"][::core::mem::offset_of!(STaskContext, tasks) - 0usize];
    ["Offset of field: STaskContext::currentTask"]
        [::core::mem::offset_of!(STaskContext, currentTask) - 640usize];
    ["Offset of field: STaskContext::numTasks"]
        [::core::mem::offset_of!(STaskContext, numTasks) - 644usize];
    ["Offset of field: STaskContext::kernelError"]
        [::core::mem::offset_of!(STaskContext, kernelError) - 648usize];
    ["Offset of field: STaskContext::kernelErrorData"]
        [::core::mem::offset_of!(STaskContext, kernelErrorData) - 652usize];
    ["Offset of field: STaskContext::hartID"]
        [::core::mem::offset_of!(STaskContext, hartID) - 664usize];
};
pub type __FILE = __BindgenOpaqueArray<u32, 26usize>;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _bindgen_opaque_blob: [u32; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _glue"][::core::mem::size_of::<_glue>() - 12usize];
    ["Alignment of _glue"][::core::mem::align_of::<_glue>() - 4usize];
};
#[repr(C)]
#[repr(align(8))]
pub struct _reent {
    pub _bindgen_opaque_blob: [u64; 36usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u64; 25usize],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u64; 25usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>() - 200usize];
    ["Alignment of _reent__bindgen_ty_1__bindgen_ty_1"]
        [::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent__bindgen_ty_1"][::core::mem::size_of::<_reent__bindgen_ty_1>() - 200usize];
    ["Alignment of _reent__bindgen_ty_1"][::core::mem::align_of::<_reent__bindgen_ty_1>() - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent"][::core::mem::size_of::<_reent>() - 288usize];
    ["Alignment of _reent"][::core::mem::align_of::<_reent>() - 8usize];
};
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub const EVideoMode_EVM_320_Wide: EVideoMode = 0;
pub const EVideoMode_EVM_640_Wide: EVideoMode = 1;
pub const EVideoMode_EVM_Count: EVideoMode = 2;
pub type EVideoMode = ::core::ffi::c_uint;
pub const EColorMode_ECM_8bit_Indexed: EColorMode = 0;
pub const EColorMode_ECM_16bit_RGB: EColorMode = 1;
pub const EColorMode_ECM_Count: EColorMode = 2;
pub type EColorMode = ::core::ffi::c_uint;
pub const EVideoScanoutEnable_EVS_Disable: EVideoScanoutEnable = 0;
pub const EVideoScanoutEnable_EVS_Enable: EVideoScanoutEnable = 1;
pub const EVideoScanoutEnable_EVS_Count: EVideoScanoutEnable = 2;
pub type EVideoScanoutEnable = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVideoContext {
    pub m_vmode: EVideoMode,
    pub m_cmode: EColorMode,
    pub m_scanEnable: EVideoScanoutEnable,
    pub m_strideInWords: u32,
    pub m_scanoutAddressCacheAligned: u32,
    pub m_cpuWriteAddressCacheAligned: u32,
    pub m_graphicsWidth: u32,
    pub m_graphicsHeight: u32,
    pub m_consoleWidth: u16,
    pub m_consoleHeight: u16,
    pub m_cursorX: u16,
    pub m_cursorY: u16,
    pub m_consoleUpdated: u16,
    pub m_caretX: u16,
    pub m_caretY: u16,
    pub m_consoleColor: u8,
    pub m_caretBlink: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EVideoContext"][::core::mem::size_of::<EVideoContext>() - 48usize];
    ["Alignment of EVideoContext"][::core::mem::align_of::<EVideoContext>() - 4usize];
    ["Offset of field: EVideoContext::m_vmode"]
        [::core::mem::offset_of!(EVideoContext, m_vmode) - 0usize];
    ["Offset of field: EVideoContext::m_cmode"]
        [::core::mem::offset_of!(EVideoContext, m_cmode) - 4usize];
    ["Offset of field: EVideoContext::m_scanEnable"]
        [::core::mem::offset_of!(EVideoContext, m_scanEnable) - 8usize];
    ["Offset of field: EVideoContext::m_strideInWords"]
        [::core::mem::offset_of!(EVideoContext, m_strideInWords) - 12usize];
    ["Offset of field: EVideoContext::m_scanoutAddressCacheAligned"]
        [::core::mem::offset_of!(EVideoContext, m_scanoutAddressCacheAligned) - 16usize];
    ["Offset of field: EVideoContext::m_cpuWriteAddressCacheAligned"]
        [::core::mem::offset_of!(EVideoContext, m_cpuWriteAddressCacheAligned) - 20usize];
    ["Offset of field: EVideoContext::m_graphicsWidth"]
        [::core::mem::offset_of!(EVideoContext, m_graphicsWidth) - 24usize];
    ["Offset of field: EVideoContext::m_graphicsHeight"]
        [::core::mem::offset_of!(EVideoContext, m_graphicsHeight) - 28usize];
    ["Offset of field: EVideoContext::m_consoleWidth"]
        [::core::mem::offset_of!(EVideoContext, m_consoleWidth) - 32usize];
    ["Offset of field: EVideoContext::m_consoleHeight"]
        [::core::mem::offset_of!(EVideoContext, m_consoleHeight) - 34usize];
    ["Offset of field: EVideoContext::m_cursorX"]
        [::core::mem::offset_of!(EVideoContext, m_cursorX) - 36usize];
    ["Offset of field: EVideoContext::m_cursorY"]
        [::core::mem::offset_of!(EVideoContext, m_cursorY) - 38usize];
    ["Offset of field: EVideoContext::m_consoleUpdated"]
        [::core::mem::offset_of!(EVideoContext, m_consoleUpdated) - 40usize];
    ["Offset of field: EVideoContext::m_caretX"]
        [::core::mem::offset_of!(EVideoContext, m_caretX) - 42usize];
    ["Offset of field: EVideoContext::m_caretY"]
        [::core::mem::offset_of!(EVideoContext, m_caretY) - 44usize];
    ["Offset of field: EVideoContext::m_consoleColor"]
        [::core::mem::offset_of!(EVideoContext, m_consoleColor) - 46usize];
    ["Offset of field: EVideoContext::m_caretBlink"]
        [::core::mem::offset_of!(EVideoContext, m_caretBlink) - 47usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVideoSwapContext {
    pub cycle: u32,
    pub readpage: *mut u8,
    pub writepage: *mut u8,
    pub framebufferA: *mut u8,
    pub framebufferB: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EVideoSwapContext"][::core::mem::size_of::<EVideoSwapContext>() - 20usize];
    ["Alignment of EVideoSwapContext"][::core::mem::align_of::<EVideoSwapContext>() - 4usize];
    ["Offset of field: EVideoSwapContext::cycle"]
        [::core::mem::offset_of!(EVideoSwapContext, cycle) - 0usize];
    ["Offset of field: EVideoSwapContext::readpage"]
        [::core::mem::offset_of!(EVideoSwapContext, readpage) - 4usize];
    ["Offset of field: EVideoSwapContext::writepage"]
        [::core::mem::offset_of!(EVideoSwapContext, writepage) - 8usize];
    ["Offset of field: EVideoSwapContext::framebufferA"]
        [::core::mem::offset_of!(EVideoSwapContext, framebufferA) - 12usize];
    ["Offset of field: EVideoSwapContext::framebufferB"]
        [::core::mem::offset_of!(EVideoSwapContext, framebufferB) - 16usize];
};
pub type __builtin_va_list = u32;
unsafe extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn strtoumax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn strtoimax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
    pub fn strtoumax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
    pub fn APUAllocateBuffer(_size: u32) -> *mut u8;
    pub fn APUSetBufferSize(audioBufferSize: u32);
    pub fn APUStartDMA(audioBufferAddress16byteAligned: u32);
    pub fn APUSetSampleRate(sampleRate: EAPUSampleRate);
    pub fn E32ReadTime() -> u64;
    pub fn E32ReadCycles() -> u64;
    pub fn E32ReadRetiredInstructions() -> u64;
    pub fn E32SetTimeCompare(future: u64);
    pub fn ClockToMs(clk: u64) -> u32;
    pub fn ClockToUs(clk: u64) -> u32;
    pub fn ClockMsToHMS(ms: u32, hours: *mut u32, minutes: *mut u32, seconds: *mut u32);
    pub fn E32Sleep(ticks: u64);
    pub fn E32WriteMemMappedCSR(_hart: u32, _csr: u32, _value: u32);
    pub fn E32ReadMemMappedCSR(_hart: u32, _csr: u32) -> u32;
    pub fn E32SetupCPU(hartid: u32, workerThread: *mut ::core::ffi::c_void);
    pub fn E32ResetCPU(hartid: u32);
    pub fn E32ClearReset(hartid: u32);
    pub fn E32BeginCriticalSection();
    pub fn E32EndCriticalSection();
    pub fn E32GetScratchpad() -> u32;
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
    pub fn getcwd(buf: *mut ::core::ffi::c_char, size: usize) -> *mut ::core::ffi::c_char;
    pub fn chdir(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ReadAxisState(scandata: *mut u8);
    pub fn ProcessAxisState(scandata: *mut u8);
    pub fn ReadButtonState(scandata: *mut u8);
    pub fn ProcessButtonState(scandata: *mut u8);
    pub fn UpdateJoystickState();
    pub fn JoystickGetState() -> *mut SJoystickState;
    pub fn ReadKeyState(scandata: *mut u8);
    pub fn ProcessKeyState(scandata: *mut u8);
    pub fn UpdateKeyboardState(scandata: *mut u8);
    pub fn KeyboardGetState() -> *mut SKeyboardState;
    pub fn KeyboardScanCodeToASCII(scanCode: u8, lowercase: u8) -> u8;
    pub fn KeyRingBufferReset();
    pub fn KeyRingBufferRead(pvDest: *mut ::core::ffi::c_void, cbDest: u32) -> u32;
    pub fn KeyRingBufferWrite(pvSrc: *const ::core::ffi::c_void, cbSrc: u32) -> u32;
    pub fn LEDGetState() -> u32;
    pub fn LEDSetState(state: u32);
    pub fn mini_vsnprintf(
        buffer: *mut ::core::ffi::c_char,
        buffer_len: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        va: va_list,
    ) -> ::core::ffi::c_int;
    pub fn mini_snprintf(
        buffer: *mut ::core::ffi::c_char,
        buffer_len: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn c_isspace(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn c_isdigit(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn c_sscanf(
        buff: *const ::core::ffi::c_char,
        format: *mut ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn c_getch() -> ::core::ffi::c_char;
    pub fn c_getbackch(b: ::core::ffi::c_char) -> bool;
    pub fn getch() -> ::core::ffi::c_int;
    pub fn SDCardStartup() -> ::core::ffi::c_int;
    pub fn SDIOControl(cmd: u8, buffer: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn SDReadMultipleBlocks(
        datablock: *mut u8,
        numblocks: u32,
        blockaddress: u32,
    ) -> ::core::ffi::c_int;
    pub fn SDWriteMultipleBlocks(
        datablock: *const u8,
        numblocks: u32,
        blockaddress: u32,
    ) -> ::core::ffi::c_int;
    pub fn SerialInRingBufferReset();
    pub fn SerialInRingBufferRead(pvDest: *mut ::core::ffi::c_void, cbDest: u32) -> u32;
    pub fn SerialInRingBufferWrite(pvSrc: *const ::core::ffi::c_void, cbSrc: u32) -> u32;
    pub fn TaskGetContext(_hartid: u32) -> *mut STaskContext;
    pub fn TaskGetSharedMemory() -> *mut ::core::ffi::c_void;
    pub fn TaskAdd(
        _ctx: *mut STaskContext,
        _name: *const ::core::ffi::c_char,
        _task: taskfunc,
        _initialState: ETaskState,
        _runLength: u32,
        _stackAddress: u32,
    ) -> ::core::ffi::c_int;
    pub fn TaskSwitchToNext(_ctx: *mut STaskContext) -> u32;
    pub fn TaskExitCurrentTask(_ctx: *mut STaskContext);
    pub fn TaskExitTaskWithID(_ctx: *mut STaskContext, _taskid: u32, _signal: u32);
    pub fn TaskYield();
    pub fn TaskSetState(_ctx: *mut STaskContext, _taskid: u32, _state: ETaskState);
    pub fn TaskGetState(_ctx: *mut STaskContext, _taskid: u32) -> ETaskState;
    pub fn TaskGetPC(_ctx: *mut STaskContext, _taskid: u32) -> u32;
    pub fn atan(arg1: f64) -> f64;
    pub fn cos(arg1: f64) -> f64;
    pub fn sin(arg1: f64) -> f64;
    pub fn tan(arg1: f64) -> f64;
    pub fn tanh(arg1: f64) -> f64;
    pub fn frexp(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
    pub fn ceil(arg1: f64) -> f64;
    pub fn fabs(arg1: f64) -> f64;
    pub fn floor(arg1: f64) -> f64;
    pub fn acos(arg1: f64) -> f64;
    pub fn asin(arg1: f64) -> f64;
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
    pub fn cosh(arg1: f64) -> f64;
    pub fn sinh(arg1: f64) -> f64;
    pub fn exp(arg1: f64) -> f64;
    pub fn ldexp(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
    pub fn log(arg1: f64) -> f64;
    pub fn log10(arg1: f64) -> f64;
    pub fn pow(arg1: f64, arg2: f64) -> f64;
    pub fn sqrt(arg1: f64) -> f64;
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
    pub fn finite(arg1: f64) -> ::core::ffi::c_int;
    pub fn finitef(arg1: f32) -> ::core::ffi::c_int;
    pub fn isinff(arg1: f32) -> ::core::ffi::c_int;
    pub fn isnanf(arg1: f32) -> ::core::ffi::c_int;
    pub fn isinf(arg1: f64) -> ::core::ffi::c_int;
    pub fn isnan(arg1: f64) -> ::core::ffi::c_int;
    pub fn infinity() -> f64;
    pub fn nan(arg1: *const ::core::ffi::c_char) -> f64;
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
    pub fn logb(arg1: f64) -> f64;
    pub fn ilogb(arg1: f64) -> ::core::ffi::c_int;
    pub fn asinh(arg1: f64) -> f64;
    pub fn cbrt(arg1: f64) -> f64;
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
    pub fn rint(arg1: f64) -> f64;
    pub fn scalbn(arg1: f64, arg2: ::core::ffi::c_int) -> f64;
    pub fn exp2(arg1: f64) -> f64;
    pub fn scalbln(arg1: f64, arg2: ::core::ffi::c_long) -> f64;
    pub fn tgamma(arg1: f64) -> f64;
    pub fn nearbyint(arg1: f64) -> f64;
    pub fn lrint(arg1: f64) -> ::core::ffi::c_long;
    pub fn llrint(arg1: f64) -> ::core::ffi::c_longlong;
    pub fn round(arg1: f64) -> f64;
    pub fn lround(arg1: f64) -> ::core::ffi::c_long;
    pub fn llround(arg1: f64) -> ::core::ffi::c_longlong;
    pub fn trunc(arg1: f64) -> f64;
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::core::ffi::c_int) -> f64;
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
    pub fn log1p(arg1: f64) -> f64;
    pub fn expm1(arg1: f64) -> f64;
    pub fn acosh(arg1: f64) -> f64;
    pub fn atanh(arg1: f64) -> f64;
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
    pub fn gamma(arg1: f64) -> f64;
    pub fn lgamma(arg1: f64) -> f64;
    pub fn erf(arg1: f64) -> f64;
    pub fn erfc(arg1: f64) -> f64;
    pub fn log2(arg1: f64) -> f64;
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
    pub fn atanf(arg1: f32) -> f32;
    pub fn cosf(arg1: f32) -> f32;
    pub fn sinf(arg1: f32) -> f32;
    pub fn tanf(arg1: f32) -> f32;
    pub fn tanhf(arg1: f32) -> f32;
    pub fn frexpf(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
    pub fn ceilf(arg1: f32) -> f32;
    pub fn fabsf(arg1: f32) -> f32;
    pub fn floorf(arg1: f32) -> f32;
    pub fn acosf(arg1: f32) -> f32;
    pub fn asinf(arg1: f32) -> f32;
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
    pub fn coshf(arg1: f32) -> f32;
    pub fn sinhf(arg1: f32) -> f32;
    pub fn expf(arg1: f32) -> f32;
    pub fn ldexpf(arg1: f32, arg2: ::core::ffi::c_int) -> f32;
    pub fn logf(arg1: f32) -> f32;
    pub fn log10f(arg1: f32) -> f32;
    pub fn powf(arg1: f32, arg2: f32) -> f32;
    pub fn sqrtf(arg1: f32) -> f32;
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
    pub fn exp2f(arg1: f32) -> f32;
    pub fn scalblnf(arg1: f32, arg2: ::core::ffi::c_long) -> f32;
    pub fn tgammaf(arg1: f32) -> f32;
    pub fn nearbyintf(arg1: f32) -> f32;
    pub fn lrintf(arg1: f32) -> ::core::ffi::c_long;
    pub fn llrintf(arg1: f32) -> ::core::ffi::c_longlong;
    pub fn roundf(arg1: f32) -> f32;
    pub fn lroundf(arg1: f32) -> ::core::ffi::c_long;
    pub fn llroundf(arg1: f32) -> ::core::ffi::c_longlong;
    pub fn truncf(arg1: f32) -> f32;
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::core::ffi::c_int) -> f32;
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
    pub fn infinityf() -> f32;
    pub fn nanf(arg1: *const ::core::ffi::c_char) -> f32;
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
    pub fn logbf(arg1: f32) -> f32;
    pub fn ilogbf(arg1: f32) -> ::core::ffi::c_int;
    pub fn asinhf(arg1: f32) -> f32;
    pub fn cbrtf(arg1: f32) -> f32;
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
    pub fn rintf(arg1: f32) -> f32;
    pub fn scalbnf(arg1: f32, arg2: ::core::ffi::c_int) -> f32;
    pub fn log1pf(arg1: f32) -> f32;
    pub fn expm1f(arg1: f32) -> f32;
    pub fn acoshf(arg1: f32) -> f32;
    pub fn atanhf(arg1: f32) -> f32;
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
    pub fn gammaf(arg1: f32) -> f32;
    pub fn lgammaf(arg1: f32) -> f32;
    pub fn erff(arg1: f32) -> f32;
    pub fn erfcf(arg1: f32) -> f32;
    pub fn log2f(arg1: f32) -> f32;
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
    pub fn drem(arg1: f64, arg2: f64) -> f64;
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
    pub fn gamma_r(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
    pub fn lgamma_r(arg1: f64, arg2: *mut ::core::ffi::c_int) -> f64;
    pub fn gammaf_r(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::core::ffi::c_int) -> f32;
    pub fn y0(arg1: f64) -> f64;
    pub fn y1(arg1: f64) -> f64;
    pub fn yn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
    pub fn j0(arg1: f64) -> f64;
    pub fn j1(arg1: f64) -> f64;
    pub fn jn(arg1: ::core::ffi::c_int, arg2: f64) -> f64;
    pub fn y0f(arg1: f32) -> f32;
    pub fn y1f(arg1: f32) -> f32;
    pub fn ynf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
    pub fn j0f(arg1: f32) -> f32;
    pub fn j1f(arg1: f32) -> f32;
    pub fn jnf(arg1: ::core::ffi::c_int, arg2: f32) -> f32;
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn tempnam(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: __builtin_va_list)
    -> ::core::ffi::c_int;
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> ::core::ffi::c_int;
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn getchar() -> ::core::ffi::c_int;
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
    pub fn rewind(arg1: *mut FILE);
    pub fn clearerr(arg1: *mut FILE);
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn perror(arg1: *const ::core::ffi::c_char);
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
    -> *mut FILE;
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ftello(arg1: *mut FILE) -> off_t;
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vscanf(arg1: *const ::core::ffi::c_char, arg2: __builtin_va_list) -> ::core::ffi::c_int;
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> ::core::ffi::c_int;
    pub fn asiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn asniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
    pub fn asnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
    pub fn diprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn iprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn iscanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn siprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn siscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn sniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn vasiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vasniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
    pub fn vasnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
    pub fn vdiprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn viprintf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
    pub fn viscanf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
    pub fn vsiprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsiscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn vsniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
    pub fn flockfile(arg1: *mut FILE);
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn funlockfile(arg1: *mut FILE);
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
    pub fn open_memstream(arg1: *mut *mut ::core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
    pub fn vdprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn clearerr_unlocked(arg1: *mut FILE);
    pub fn feof_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
    pub fn fputc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
    pub fn UARTInterceptSetState(state: ::core::ffi::c_int);
    pub fn UARTGetStatus() -> u32;
    pub fn UARTSetControl(ctl: u32);
    pub fn UARTReceiveData() -> u32;
    pub fn UARTSendByte(data: u8);
    pub fn UARTSendBlock(data: *mut u8, numBytes: u32);
    pub fn UARTPrintf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn VPUAllocateBuffer(_size: u32) -> *mut u8;
    pub fn VPUGetDimensions(_mode: EVideoMode, _width: *mut u32, _height: *mut u32);
    pub fn VPUSetDefaultPalette(_context: *mut EVideoContext);
    pub fn VPUSetVMode(_context: *mut EVideoContext, _scanEnable: EVideoScanoutEnable);
    pub fn VPUSetScanoutAddress(_context: *mut EVideoContext, _scanOutAddress64ByteAligned: u32);
    pub fn VPUSetWriteAddress(_context: *mut EVideoContext, _cpuWriteAddress64ByteAligned: u32);
    pub fn VPUSetPal(_paletteIndex: u8, _red: u32, _green: u32, _blue: u32);
    pub fn VPUReadVBlankCounter() -> u32;
    pub fn VPUGetScanline() -> u32;
    pub fn VPUSwapPages(_vx: *mut EVideoContext, _sc: *mut EVideoSwapContext);
    pub fn VPUWaitVSync();
    pub fn VPUPrintString(
        _context: *mut EVideoContext,
        _foregroundIndex: u8,
        _backgroundIndex: u8,
        _x: u16,
        _y: u16,
        _message: *const ::core::ffi::c_char,
        _length: ::core::ffi::c_int,
    );
    pub fn VPUConsoleSetColors(
        _context: *mut EVideoContext,
        _foregroundIndex: u8,
        _backgroundIndex: u8,
    );
    pub fn VPUConsoleClear(_context: *mut EVideoContext);
    pub fn VPUConsoleSetCursor(_context: *mut EVideoContext, _x: u16, _y: u16);
    pub fn VPUConsolePrint(
        _context: *mut EVideoContext,
        _message: *const ::core::ffi::c_char,
        _length: ::core::ffi::c_int,
    );
    pub fn VPUConsoleResolve(_context: *mut EVideoContext);
    pub fn VPUConsoleSetCaret(_context: *mut EVideoContext, _x: u16, _y: u16, _blink: u16);
    pub fn VPUConsoleClearLine(_context: *mut EVideoContext, _y: u16);
    pub fn VPUConsoleFillLine(
        _context: *mut EVideoContext,
        _character: ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn VPUConsoleScrollUp(_context: *mut EVideoContext);
    pub fn VPUClear(_context: *mut EVideoContext, _colorWord: u32);
    pub fn VPUGetKernelGfxContext() -> *mut EVideoContext;
}
