#![allow(bad_style)]
/* automatically generated by rust-bindgen 0.71.1 */

pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::core::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::core::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::core::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::core::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    _unused: [u8; 0],
}
pub const EAPUSampleRate_ASR_44_100_Hz: EAPUSampleRate = 0;
pub const EAPUSampleRate_ASR_22_050_Hz: EAPUSampleRate = 1;
pub const EAPUSampleRate_ASR_11_025_Hz: EAPUSampleRate = 2;
pub const EAPUSampleRate_ASR_Halt: EAPUSampleRate = 3;
pub type EAPUSampleRate = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __sigset_t = ::core::ffi::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::core::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::core::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::core::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::core::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::core::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::core::mem::size_of::<fd_set>() - 8usize];
    ["Alignment of fd_set"][::core::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::__fds_bits"][::core::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type va_list = __builtin_va_list;
pub type taskfunc = ::core::option::Option<unsafe extern "C" fn()>;
pub const ETaskState_TS_UNKNOWN: ETaskState = 0;
pub const ETaskState_TS_PAUSED: ETaskState = 1;
pub const ETaskState_TS_RUNNING: ETaskState = 2;
pub const ETaskState_TS_TERMINATING: ETaskState = 3;
pub const ETaskState_TS_TERMINATED: ETaskState = 4;
pub type ETaskState = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STask {
    pub HART: u32,
    pub runLength: u32,
    pub state: ETaskState,
    pub exitCode: u32,
    pub regs: [u32; 32usize],
    pub name: [::core::ffi::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of STask"][::core::mem::size_of::<STask>() - 160usize];
    ["Alignment of STask"][::core::mem::align_of::<STask>() - 4usize];
    ["Offset of field: STask::HART"][::core::mem::offset_of!(STask, HART) - 0usize];
    ["Offset of field: STask::runLength"][::core::mem::offset_of!(STask, runLength) - 4usize];
    ["Offset of field: STask::state"][::core::mem::offset_of!(STask, state) - 8usize];
    ["Offset of field: STask::exitCode"][::core::mem::offset_of!(STask, exitCode) - 12usize];
    ["Offset of field: STask::regs"][::core::mem::offset_of!(STask, regs) - 16usize];
    ["Offset of field: STask::name"][::core::mem::offset_of!(STask, name) - 144usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STaskContext {
    pub tasks: [STask; 4usize],
    pub currentTask: i32,
    pub numTasks: i32,
    pub interceptUART: i32,
    pub kernelError: i32,
    pub kernelErrorData: [i32; 3usize],
    pub hartID: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of STaskContext"][::core::mem::size_of::<STaskContext>() - 672usize];
    ["Alignment of STaskContext"][::core::mem::align_of::<STaskContext>() - 4usize];
    ["Offset of field: STaskContext::tasks"][::core::mem::offset_of!(STaskContext, tasks) - 0usize];
    ["Offset of field: STaskContext::currentTask"]
        [::core::mem::offset_of!(STaskContext, currentTask) - 640usize];
    ["Offset of field: STaskContext::numTasks"]
        [::core::mem::offset_of!(STaskContext, numTasks) - 644usize];
    ["Offset of field: STaskContext::interceptUART"]
        [::core::mem::offset_of!(STaskContext, interceptUART) - 648usize];
    ["Offset of field: STaskContext::kernelError"]
        [::core::mem::offset_of!(STaskContext, kernelError) - 652usize];
    ["Offset of field: STaskContext::kernelErrorData"]
        [::core::mem::offset_of!(STaskContext, kernelErrorData) - 656usize];
    ["Offset of field: STaskContext::hartID"]
        [::core::mem::offset_of!(STaskContext, hartID) - 668usize];
};
pub const EVideoMode_EVM_320_Wide: EVideoMode = 0;
pub const EVideoMode_EVM_640_Wide: EVideoMode = 1;
pub const EVideoMode_EVM_Count: EVideoMode = 2;
pub type EVideoMode = ::core::ffi::c_uint;
pub const EColorMode_ECM_8bit_Indexed: EColorMode = 0;
pub const EColorMode_ECM_16bit_RGB: EColorMode = 1;
pub const EColorMode_ECM_Count: EColorMode = 2;
pub type EColorMode = ::core::ffi::c_uint;
pub const EVideoScanoutEnable_EVS_Disable: EVideoScanoutEnable = 0;
pub const EVideoScanoutEnable_EVS_Enable: EVideoScanoutEnable = 1;
pub const EVideoScanoutEnable_EVS_Count: EVideoScanoutEnable = 2;
pub type EVideoScanoutEnable = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVideoContext {
    pub m_vmode: EVideoMode,
    pub m_cmode: EColorMode,
    pub m_scanEnable: EVideoScanoutEnable,
    pub m_strideInWords: u32,
    pub m_scanoutAddressCacheAligned: u32,
    pub m_cpuWriteAddressCacheAligned: u32,
    pub m_graphicsWidth: u32,
    pub m_graphicsHeight: u32,
    pub m_consoleWidth: u16,
    pub m_consoleHeight: u16,
    pub m_cursorX: u16,
    pub m_cursorY: u16,
    pub m_consoleUpdated: u16,
    pub m_caretX: u16,
    pub m_caretY: u16,
    pub m_consoleColor: u8,
    pub m_caretBlink: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EVideoContext"][::core::mem::size_of::<EVideoContext>() - 48usize];
    ["Alignment of EVideoContext"][::core::mem::align_of::<EVideoContext>() - 4usize];
    ["Offset of field: EVideoContext::m_vmode"]
        [::core::mem::offset_of!(EVideoContext, m_vmode) - 0usize];
    ["Offset of field: EVideoContext::m_cmode"]
        [::core::mem::offset_of!(EVideoContext, m_cmode) - 4usize];
    ["Offset of field: EVideoContext::m_scanEnable"]
        [::core::mem::offset_of!(EVideoContext, m_scanEnable) - 8usize];
    ["Offset of field: EVideoContext::m_strideInWords"]
        [::core::mem::offset_of!(EVideoContext, m_strideInWords) - 12usize];
    ["Offset of field: EVideoContext::m_scanoutAddressCacheAligned"]
        [::core::mem::offset_of!(EVideoContext, m_scanoutAddressCacheAligned) - 16usize];
    ["Offset of field: EVideoContext::m_cpuWriteAddressCacheAligned"]
        [::core::mem::offset_of!(EVideoContext, m_cpuWriteAddressCacheAligned) - 20usize];
    ["Offset of field: EVideoContext::m_graphicsWidth"]
        [::core::mem::offset_of!(EVideoContext, m_graphicsWidth) - 24usize];
    ["Offset of field: EVideoContext::m_graphicsHeight"]
        [::core::mem::offset_of!(EVideoContext, m_graphicsHeight) - 28usize];
    ["Offset of field: EVideoContext::m_consoleWidth"]
        [::core::mem::offset_of!(EVideoContext, m_consoleWidth) - 32usize];
    ["Offset of field: EVideoContext::m_consoleHeight"]
        [::core::mem::offset_of!(EVideoContext, m_consoleHeight) - 34usize];
    ["Offset of field: EVideoContext::m_cursorX"]
        [::core::mem::offset_of!(EVideoContext, m_cursorX) - 36usize];
    ["Offset of field: EVideoContext::m_cursorY"]
        [::core::mem::offset_of!(EVideoContext, m_cursorY) - 38usize];
    ["Offset of field: EVideoContext::m_consoleUpdated"]
        [::core::mem::offset_of!(EVideoContext, m_consoleUpdated) - 40usize];
    ["Offset of field: EVideoContext::m_caretX"]
        [::core::mem::offset_of!(EVideoContext, m_caretX) - 42usize];
    ["Offset of field: EVideoContext::m_caretY"]
        [::core::mem::offset_of!(EVideoContext, m_caretY) - 44usize];
    ["Offset of field: EVideoContext::m_consoleColor"]
        [::core::mem::offset_of!(EVideoContext, m_consoleColor) - 46usize];
    ["Offset of field: EVideoContext::m_caretBlink"]
        [::core::mem::offset_of!(EVideoContext, m_caretBlink) - 47usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EVideoSwapContext {
    pub cycle: u32,
    pub readpage: *mut u8,
    pub writepage: *mut u8,
    pub framebufferA: *mut u8,
    pub framebufferB: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EVideoSwapContext"][::core::mem::size_of::<EVideoSwapContext>() - 20usize];
    ["Alignment of EVideoSwapContext"][::core::mem::align_of::<EVideoSwapContext>() - 4usize];
    ["Offset of field: EVideoSwapContext::cycle"]
        [::core::mem::offset_of!(EVideoSwapContext, cycle) - 0usize];
    ["Offset of field: EVideoSwapContext::readpage"]
        [::core::mem::offset_of!(EVideoSwapContext, readpage) - 4usize];
    ["Offset of field: EVideoSwapContext::writepage"]
        [::core::mem::offset_of!(EVideoSwapContext, writepage) - 8usize];
    ["Offset of field: EVideoSwapContext::framebufferA"]
        [::core::mem::offset_of!(EVideoSwapContext, framebufferA) - 12usize];
    ["Offset of field: EVideoSwapContext::framebufferB"]
        [::core::mem::offset_of!(EVideoSwapContext, framebufferB) - 16usize];
};
pub type __builtin_va_list = *mut ::core::ffi::c_void;
unsafe extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn strtoumax(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
        arg4: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::core::ffi::c_int,
    ) -> intmax_t;
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::core::ffi::c_int,
    ) -> uintmax_t;
    pub fn strtoimax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
    pub fn strtoumax_l(
        arg1: *const ::core::ffi::c_char,
        _restrict: *mut *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> intmax_t;
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::core::ffi::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
    pub fn APUAllocateBuffer(_size: u32) -> *mut u8;
    pub fn APUSetBufferSize(audioBufferSize: u32);
    pub fn APUStartDMA(audioBufferAddress16byteAligned: u32);
    pub fn APUSetSampleRate(sampleRate: EAPUSampleRate);
    pub fn E32ReadTime() -> u64;
    pub fn E32ReadCycles() -> u64;
    pub fn E32ReadRetiredInstructions() -> u64;
    pub fn E32SetTimeCompare(future: u64);
    pub fn ClockToMs(clk: u64) -> u32;
    pub fn ClockToUs(clk: u64) -> u32;
    pub fn ClockMsToHMS(ms: u32, hours: *mut u32, minutes: *mut u32, seconds: *mut u32);
    pub fn E32Sleep(ticks: u64);
    pub fn E32WriteMemMappedCSR(_hart: u32, _csr: u32, _value: u32);
    pub fn E32ReadMemMappedCSR(_hart: u32, _csr: u32) -> u32;
    pub fn E32SetupCPU(hartid: u32, workerThread: *mut ::core::ffi::c_void);
    pub fn E32ResetCPU(hartid: u32);
    pub fn E32BeginCriticalSection();
    pub fn E32EndCriticalSection();
    pub fn E32GetScratchpad() -> u32;
    pub fn select(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
    pub fn pselect(
        __n: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::core::ffi::c_int;
    pub fn getcwd(buf: *mut ::core::ffi::c_char, size: usize) -> *mut ::core::ffi::c_char;
    pub fn chdir(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ReadAxisState(scandata: *mut u8);
    pub fn ProcessAxisState(scandata: *mut u8);
    pub fn ReadButtonState(scandata: *mut u8);
    pub fn ProcessButtonState(scandata: *mut u8);
    pub fn JoystickReadState(_axisData: *mut f32, _buttonData: *mut u16);
    pub fn ReadKeyState(scandata: *mut u8);
    pub fn ProcessKeyState(scandata: *mut u8);
    pub fn KeyboardScanCodeToASCII(scanCode: u8, lowercase: u8) -> u8;
    pub fn KeyRingBufferReset();
    pub fn KeyRingBufferRead(pvDest: *mut ::core::ffi::c_void, cbDest: u32) -> u32;
    pub fn KeyRingBufferWrite(pvSrc: *const ::core::ffi::c_void, cbSrc: u32) -> u32;
    pub fn LEDGetState() -> u32;
    pub fn LEDSetState(state: u32);
    pub fn mini_vsnprintf(
        buffer: *mut ::core::ffi::c_char,
        buffer_len: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        va: va_list,
    ) -> ::core::ffi::c_int;
    pub fn mini_snprintf(
        buffer: *mut ::core::ffi::c_char,
        buffer_len: ::core::ffi::c_uint,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn c_isspace(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn c_isdigit(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn c_sscanf(
        buff: *const ::core::ffi::c_char,
        format: *mut ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
    pub fn c_getch() -> ::core::ffi::c_char;
    pub fn c_getbackch(b: ::core::ffi::c_char) -> bool;
    pub fn getch() -> ::core::ffi::c_int;
    pub fn SDCardStartup() -> ::core::ffi::c_int;
    pub fn SDIOControl(cmd: u8, buffer: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
    pub fn SDReadMultipleBlocks(
        datablock: *mut u8,
        numblocks: u32,
        blockaddress: u32,
    ) -> ::core::ffi::c_int;
    pub fn SDWriteMultipleBlocks(
        datablock: *const u8,
        numblocks: u32,
        blockaddress: u32,
    ) -> ::core::ffi::c_int;
    pub fn SerialInRingBufferReset();
    pub fn SerialInRingBufferRead(pvDest: *mut ::core::ffi::c_void, cbDest: u32) -> u32;
    pub fn SerialInRingBufferWrite(pvSrc: *const ::core::ffi::c_void, cbSrc: u32) -> u32;
    pub fn TaskGetContext(_hartid: u32) -> *mut STaskContext;
    pub fn TaskGetSharedMemory() -> *mut ::core::ffi::c_void;
    pub fn TaskAdd(
        _ctx: *mut STaskContext,
        _name: *const ::core::ffi::c_char,
        _task: taskfunc,
        _initialState: ETaskState,
        _runLength: u32,
        _stackAddress: u32,
    ) -> ::core::ffi::c_int;
    pub fn TaskSwitchToNext(_ctx: *mut STaskContext) -> u32;
    pub fn TaskExitCurrentTask(_ctx: *mut STaskContext);
    pub fn TaskExitTaskWithID(_ctx: *mut STaskContext, _taskid: u32, _signal: u32);
    pub fn TaskYield();
    pub fn TaskSetState(_ctx: *mut STaskContext, _taskid: u32, _state: ETaskState);
    pub fn TaskGetState(_ctx: *mut STaskContext, _taskid: u32) -> ETaskState;
    pub fn TaskGetPC(_ctx: *mut STaskContext, _taskid: u32) -> u32;
    pub fn UARTGetStatus() -> u32;
    pub fn UARTSetControl(ctl: u32);
    pub fn UARTReceiveData() -> u32;
    pub fn UARTSendByte(data: u8);
    pub fn UARTSendBlock(data: *mut u8, numBytes: u32);
    pub fn UARTPrintf(fmt: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
    pub fn VPUAllocateBuffer(_size: u32) -> *mut u8;
    pub fn VPUGetDimensions(_mode: EVideoMode, _width: *mut u32, _height: *mut u32);
    pub fn VPUSetDefaultPalette(_context: *mut EVideoContext);
    pub fn VPUSetVMode(_context: *mut EVideoContext, _scanEnable: EVideoScanoutEnable);
    pub fn VPUSetScanoutAddress(_context: *mut EVideoContext, _scanOutAddress64ByteAligned: u32);
    pub fn VPUSetWriteAddress(_context: *mut EVideoContext, _cpuWriteAddress64ByteAligned: u32);
    pub fn VPUSetPal(_paletteIndex: u8, _red: u32, _green: u32, _blue: u32);
    pub fn VPUReadVBlankCounter() -> u32;
    pub fn VPUGetScanline() -> u32;
    pub fn VPUSwapPages(_vx: *mut EVideoContext, _sc: *mut EVideoSwapContext);
    pub fn VPUWaitVSync();
    pub fn VPUPrintString(
        _context: *mut EVideoContext,
        _foregroundIndex: u8,
        _backgroundIndex: u8,
        _x: u16,
        _y: u16,
        _message: *const ::core::ffi::c_char,
        _length: ::core::ffi::c_int,
    );
    pub fn VPUConsoleSetColors(
        _context: *mut EVideoContext,
        _foregroundIndex: u8,
        _backgroundIndex: u8,
    );
    pub fn VPUConsoleClear(_context: *mut EVideoContext);
    pub fn VPUConsoleSetCursor(_context: *mut EVideoContext, _x: u16, _y: u16);
    pub fn VPUConsolePrint(
        _context: *mut EVideoContext,
        _message: *const ::core::ffi::c_char,
        _length: ::core::ffi::c_int,
    );
    pub fn VPUConsoleResolve(_context: *mut EVideoContext);
    pub fn VPUConsoleSetCaret(_context: *mut EVideoContext, _x: u16, _y: u16, _blink: u16);
    pub fn VPUConsoleClearLine(_context: *mut EVideoContext, _y: u16);
    pub fn VPUConsoleFillLine(
        _context: *mut EVideoContext,
        _character: ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    pub fn VPUConsoleScrollUp(_context: *mut EVideoContext);
    pub fn VPUClear(_context: *mut EVideoContext, _colorWord: u32);
    pub fn VPUSetHBlankHandler(_handler: usize);
    pub fn VPUSetHBlankScanline(_scanline: usize);
    pub fn VPUHBlankIRQLatchSet();
    pub fn VPUHBlankIRQLatchReset();
    pub fn VPUEnableHBlankInterrupt();
    pub fn VPUDisableHBlankInterrupt();
    pub fn VPUGetKernelGfxContext() -> *mut EVideoContext;
}
